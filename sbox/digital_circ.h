#ifndef DIGITAL_CIRCR_
#define DIGITAL_CIRCR_

#include <cstdint>
typedef bool bit;

namespace dcirc {

bit x[8];
bit p[27], q[9], r[6], s[4], t[4], a[6], b[10], c[6], d[2], z[4], k[5], u[18], v[30];
bit y[8];

int solve(uint16_t alpha) {
	for (int i = 0; i < 8; i++) {
		x[i] = (alpha >> (7 - i)) & 1;
	}
	// part1;
	p[13] = x[7];
	p[13] ^= 1;
	p[15] = x[2] ^ x[6];
	p[17] = x[7] ^ p[15];
	p[19] = x[0] ^ x[5];
	p[11] = x[3] ^ p[19];
	p[5] = p[17] ^ p[11];
	p[20] = x[1] ^ p[19];
	p[22] = x[2] ^ x[4];
	p[12] = x[7] ^ p[22];
	p[3] = x[0] ^ p[12];
	p[1] = p[5] ^ p[3];
	p[2] = p[20] ^ p[3];
	p[7] = x[7] ^ p[1];
	p[6] = p[19] ^ p[7];
	p[0] = p[12] ^ p[6];
	p[9] = p[15] ^ p[3] ^ 1;
	p[10] = x[6] ^ p[2];
	p[8] = p[6] ^ p[10];
	p[14] = x[6] ^ p[6];
	p[18] = p[19] ^ p[22];
	p[21] = x[1] ^ p[22];
	p[4] = p[5] ^ p[21];
	p[16] = p[10] ^ p[4];
	p[23] = x[3] ^ p[10] ^ 1;
	p[24] = p[11] ^ p[10];
	p[25] = x[1] ^ p[24] ^ 1;
	p[26] = x[4] ^ p[6];
	p[7] ^= 1;
	p[15] ^= 1;
	p[19] ^= 1;
	p[22] ^= 1;
	q[0] = p[0] & p[1];
	q[1] = p[2] & p[3];
	q[2] = p[4] & p[5];
	q[3] = p[6] & p[7];
	q[4] = p[8] & p[9];
	q[5] = p[10] & p[11];
	q[6] = p[12] & p[13];
	q[7] = p[14] & p[15];
	q[8] = p[16] & p[17];
	r[0] = q[0] ^ q[2];
	r[1] = q[1] ^ q[2];
	r[2] = q[3] ^ q[4];
	r[3] = q[3] ^ q[5];
	r[4] = q[6] ^ q[8];
	r[5] = q[7] ^ q[8];
	s[0] = r[0] ^ r[4];
	s[1] = r[1] ^ r[5];
	s[2] = r[2] ^ r[4];
	s[3] = r[3] ^ r[5];
	t[0] = p[26] ^ s[0];
	t[1] = p[25] ^ s[1];
	t[2] = p[20] ^ s[2];
	t[3] = p[18] ^ s[3];
	// part2;
	a[0] = t[1] ^ t[2];
	a[1] = t[0] ^ t[1];
	a[2] = t[2] ^ t[3];
	a[3] = t[0] ^ t[2];
	a[4] = t[1] ^ t[3];
	a[5] = t[3];
	b[0] = t[0];
	b[1] = a[0];
	b[1] ^= 1;
	c[0] = b[0] & b[1];
	d[0] = a[0] ^ a[5];
	b[2] = d[0] ^ c[0];
	b[3] = a[1] ^ c[0] ^ 1;
	c[1] = b[2] & b[3];
	b[4] = b[3] ^ a[2] ^ c[1];
	b[5] = a[0] ^ c[1];
	c[2] = b[4] & b[5];
	d[1] = a[3] ^ c[2];
	b[6] = d[1] ^ a[5];
	b[7] = d[0] ^ c[2];
	c[3] = b[6] & b[7];
	b[8] = d[1] ^ c[0] ^ c[1];
	b[9] = a[1] ^ a[5] ^ c[1];
	c[4] = b[8] & b[9];
	c[5] = c[2] ^ c[3];
	z[0] = b[2] ^ c[5] ^ c[4];
	z[1] = a[4] ^ c[2] ^ c[4];
	z[2] = b[4] ^ c[3] ^ 1;
	z[3] = b[3] ^ c[5] ^ 1;
	// part3;
	k[0] = z[0] ^ z[2];
	k[1] = z[1] ^ z[3];
	k[2] = z[0] ^ z[1];
	k[3] = z[2] ^ z[3];
	k[4] = k[0] ^ k[1];
	u[0] = p[18] & k[4];
	u[1] = p[20] & k[0];
	u[2] = p[21] & k[1];
	u[3] = p[19] & k[2];
	u[4] = p[23] & z[0];
	u[5] = p[24] & z[1];
	u[6] = p[22] & k[3];
	u[7] = p[25] & z[2];
	u[8] = p[26] & z[3];
	u[9] = p[0] & k[4];
	u[10] = p[2] & k[0];
	u[11] = p[4] & k[1];
	u[12] = p[6] & k[2];
	u[13] = p[8] & z[0];
	u[14] = p[10] & z[1];
	u[15] = p[12] & k[3];
	u[16] = p[14] & z[2];
	u[17] = p[16] & z[3];
	v[0] = u[9] ^ u[12];
	v[1] = u[11] ^ u[14];
	v[2] = u[16] ^ v[0];
	v[3] = v[1] ^ v[2];
	y[0] = u[15] ^ v[3];
	v[5] = u[13] ^ u[17];
	v[6] = u[12] ^ v[3];
	y[4] = v[5] ^ v[6];
	v[8] = u[5] ^ u[6];
	v[9] = u[7] ^ v[8];
	v[10] = u[4] ^ v[9];
	y[6] = y[4] ^ v[10] ^ 1;
	v[12] = u[10] ^ v[2];
	v[13] = v[5] ^ v[12];
	y[3] = v[10] ^ v[13];
	v[15] = u[0] ^ u[3];
	v[16] = v[9] ^ v[15];
	v[17] = u[2] ^ v[16];
	v[18] = y[3] ^ v[17];
	y[7] = y[0] ^ v[18] ^ 1;
	v[20] = u[13] ^ v[0];
	v[21] = u[11] ^ v[20];
	y[5] = v[17] ^ v[21];
	v[23] = v[13] ^ v[16];
	v[24] = u[1] ^ v[23];
	v[25] = u[8] ^ v[24];
	y[2] = u[7] ^ v[25];
	v[27] = y[5] ^ v[24];
	v[28] = y[0] ^ v[27];
	v[29] = u[5] ^ v[28];
	y[1] = u[3] ^ v[29] ^ 1;
	y[0] ^= 1;
	y[3] ^= 1;
	uint16_t beta = 0;
	for (int i = 0; i < 8; i++) {
		beta = (beta << 1) | y[i];
	}
	return beta;
}

void get_digital_sbox(uint8_t sbox[256]) {
	for (int i = 0; i < 256; ++i) {
        sbox[i] = solve(i);
    }
}
}

#endif